<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Artificial Pretraining of Masked Language Models | Roman Castagné</title><meta name=keywords content><meta name=description content="According to Chinchilla scaling laws for Transformers [1], data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.
Thus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only artificially created data, then continue pretraining on languages with very little resources?"><meta name=author content="Roman Castagné"><link rel=canonical href=https://romancast.github.io/posts/artificial_data/><link crossorigin=anonymous href=/assets/css/stylesheet.79a1994912ea7948e20ec9dbe2189b1d939cfb3d32c259c453f6087ea09835f7.css integrity="sha256-eaGZSRLqeUjiDsnb4hibHZOc+z0ywlnEU/YIfqCYNfc=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG+9vmJ0cTS+ovo0FeA=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=https://romancast.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://romancast.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://romancast.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://romancast.github.io/apple-touch-icon.png><link rel=mask-icon href=https://romancast.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style></noscript><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.css integrity=sha384-AfEj0r4/OFrOo5t7NnNe46zW/tFgW6x/bCJG8FqQCEo3+Aro6EYUG4+cU+KJWu/X crossorigin=anonymous><script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/katex.min.js integrity=sha384-g7c+Jr9ZivxKLnZTDUhnkOnsh30B4H0rpLUpJ4jAIKs4fnJI+sEnkvrMWph2EDg4 crossorigin=anonymous></script>
<script defer src=https://cdn.jsdelivr.net/npm/katex@0.12.0/dist/contrib/auto-render.min.js integrity=sha384-mll67QQFJfxn0IYznZYonOWZ644AWYC+Pt2cHqMaRhXVrursRwvLnLaebdGIlYNa crossorigin=anonymous onload='renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"\\[",right:"\\]",display:!0},{left:"$",right:"$",display:!1},{left:"\\(",right:"\\)",display:!1}]})'></script>
<script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-123-45","auto"),ga("send","pageview"))</script><meta property="og:title" content="Artificial Pretraining of Masked Language Models"><meta property="og:description" content="According to Chinchilla scaling laws for Transformers [1], data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.
Thus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only artificially created data, then continue pretraining on languages with very little resources?"><meta property="og:type" content="article"><meta property="og:url" content="https://romancast.github.io/posts/artificial_data/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-14T00:00:00+02:00"><meta property="article:modified_time" content="2023-02-14T00:00:00+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Artificial Pretraining of Masked Language Models"><meta name=twitter:description content="According to Chinchilla scaling laws for Transformers [1], data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.
Thus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only artificially created data, then continue pretraining on languages with very little resources?"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://romancast.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Artificial Pretraining of Masked Language Models","item":"https://romancast.github.io/posts/artificial_data/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Artificial Pretraining of Masked Language Models","name":"Artificial Pretraining of Masked Language Models","description":"According to Chinchilla scaling laws for Transformers [1], data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.\nThus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only artificially created data, then continue pretraining on languages with very little resources?","keywords":[],"articleBody":"According to Chinchilla scaling laws for Transformers [1], data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.\nThus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only artificially created data, then continue pretraining on languages with very little resources? Ideally, our synthetic data could be generated quickly and be scaled to extremely large sizes as well as have properties that allow the models to “learn something”.\nLanguage Models trained on a source language can often transfer very well to a new language, even though the vocabulary is completely disjoint. Can we do the same with artificial data?\nYes, but how will it know what “New York” is?\nThe intent behind this work is not to entirely replace language data, but rather to see whether we can teach the networks to learn some simple operations before having to cope with semantics and meaning. Similar work was done for automatic summarization [2], showing that teaching a model to perform a few basic operations using synthetic data (e.g. copy one line) almost matches the performance of a fully pretrained model.\nA secondary objective of this work is to understand what features are learnt from the training data by language models, and how much are they used when transferring to another language. Previous works [3] have shown that it was possible to pre-train a model on a different modality than text (e.g. music) and still transfer to natural language with great performance. What information is learnt that makes this transfer possible?\n⚠️ Disclaimer: Our work falls into the “negative results” category. Nonetheless, we bumped into interesting questions and thought it would be nice to present our results informally here.\nThis work was done as part of my PhD supervised by Benoît Sagot and Éric de la Clergerie, funded by the PRAIRIE chair of Benoît Sagot.\nThe Method We start by training Masked Language Models on “source” data, i.e. either natural language data or synthetic data (see below for the description of our synthetic data). For all our experiments, we work with encoder models similar to BERT with 12 layers and hidden size 768, processing sequences of length at most 128. We use batches containing 256 samples and train for 100k steps with AdamW, using a linearly decaying learning rate of at most 1e-4 and a warmup for the first 10k steps. This is a modest setup in terms of training but it enables us to experiment with new ideas pretty quickly.\nWe then continue training on a target language. We keep all the source parameters except the embeddings (our source language has no vocabulary overlap with the target language) and retrain using the same hyperparameters except for the batch size which we reduce to 128 samples. We usually stop training around 50k iterations to save compute because the models have already started overfitting at that point.\nWe use the Breton subset of OSCAR 21.09 as our low-resource target language. It corresponds to around 5M tokens. In addition, Breton appears in the Wikiann NER dataset, which makes it possible to study finetuning setups.\nWe describe in the following section the source data we considered, including our synthetic language.\nWhat we tried Our methods We try to identify a few key characteristics in natural data that should appear in our artificial language as well.\nStructure; natural data has a structure, whether it be images, text or sound. Since word embeddings are context-independent, we hypothesize that the structure is mainly modelled with the Transformer layers and the positional embeddings and that we should be able to transfer it to the target language. Co-occurrence; this is a very vague term encompassing a lot of higher concepts such as meaning. However, we think it may be important to learn making context-dependent decisions. To create artificial structure, we use dependency trees from the French GSD treebank to learn a Probabilistic Context Free Grammar (PCFG). Using this PCFG, we sample new trees that we linearize to form sequences. This process yields sequences of tags corresponding each to a dependency relation.\nWe then relexicalize these tags with items from a vocabulary chosen arbitrarily. We do not apply any other linguistically-inspired rules. Our goal is rather to construct data generated from an underlying structure than “natural-sounding sentences”.\nOur first method for relexicalization (which we will call PCFG+Zipf) does not account for co-occurrences within sentences. We assign to each dependency relation a vocabulary size (computed using real statistics about that dependency relation) and a set of tokens of the corresponding size. We then relexicalize sequences of tags by drawing a token for each dependency relation from its set, using a Zipf law.\nInspired from Ri and Tsuruoka [6] we also try another method (PCFG+loglinear) for linearization which aims at enforcing a notion of context. We create vocabulary sets for each dependency relation similarly to the PCFG+Zipf method. Every token from each set is assigned a random embedding vector $v_s \\in \\mathbb{R}^d$. Then, for each sequence of tags, we randomly draw a “topic vector” $v_t\\in \\mathbb{R}^d$ and sample for each dependency relation a vocabulary element $w\\in S_{tag}$ according to the following distribution:\n$$ p(w|t) = \\frac{\\exp(v_w \\cdot v_t)}{\\sum_{s\\in S_{tag}}\\exp(v_s \\cdot v_t)} $$\nIntuitively, the words that are similar according to their (random) embeddings will be often sampled together, thus creating a notion of co-occurrence within sentences.\nFor both methods, we generate a corpus of 1 million sentences, corresponding roughly to 15 million tokens. We use a total vocabulary size of 5000 elements and keep only the 20 most used dependency relations when constructing the PCFG.\nThe Baselines The Language Model representations are surprisingly robust to new modalities and languages. Thus, previous works have for instance recycled models to create new ones in languages with fewer data [4] or added languages to multilingual models after training [5].\nOur baseline is similar. We use the same setting described earlier to train a model on English OSCAR data, then re-initialize its embeddings and retrain it on Breton data. This is a particularly efficient baseline compared to pretraining from scratch.\nAs a control and to test the influence of the source language on the transfer, we train Language Models on Czech and Turkish. They belong to different language (sub)families than Breton and have different syntax.\nAs we will see later, the three models (English, Czech and Turkish) transfer to Breton with almost the same accuracy, demonstrating a very moderate impact of the source language syntax on the final representations.\nResults We present in the following graph the MLM evaluation accuracies obtained by each of the models on the OSCAR Breton subset.\nThe models trained on synthetic data fail to significantly improve on a model trained from scratch on Breton. The models pretrained on natural language however improve by roughly 3 accuracy points compared to pretraining from scratch. Adding a level of co-occurrence (the PCFG+loglinear model) did not seem to help the transfer.\nMaximum evaluation accuracy on the Breton Masked Language Modelling task using each of the different source pretraining methods. The x-axis corresponds to the source pretraining data. “From scratch” was initialized randomly before the target pretraining.\nIn the following section, we look at a few questions that arose when trying to understand what may be the cause of the different transfer accuracies.\nAnalysis In the process of trying to design a better synthetic language and understanding the source of failure when transferring to a target (natural) language, we came across a few interesting questions and experiments that we detail here.\nHow important are position embeddings in the transfer? We transfer two types of modules when pretraining on the target language, Breton: the Transformer layers and the positional embeddings. Although we reason mostly around the Transformer layers as encoding structure in our sentences, we may be diminishing the importance of good positional embeddings trained on natural data.\nTo test this effect, we reset the positional embeddings at the beginning of pretraining on the target language and look at the validation accuracy.\nEvaluation MLM accuracy during target pretraining on Breton using the English pretrained model.\nWe can see that re-initializing the positional embeddings only delays training for a few steps, but does not impact the final performance. The same effect appears for a model trained using artificial data. From that experiment, we concluded that the Transformer layers are mostly responsible for the transfer to the target language.\nHow different are the models trained with artificial data and natural language data? The models trained on different modalities transfer with very different accuracies to the target language. Can we identify some statistics in the model parameters that correlate with a better transfer performance? To answer this question, we looked at the mean, standard deviation and maximum parameter values of every layer and every module in our models. The average weight values give very little information, as both types of models (trained on natural or synthetic data) have similar statistics.\nThe standard deviations are quite different, however. Despite being trained with the same hyperparameters, the models trained on natural data exhibit larger standard deviations than the models trained on artificial data, which stay closer to the standard deviation set at initialization. The following graph shows the standard deviations of weights and biases from every module.\nStandard deviations of each module parameter values. The x-axis corresponds to the layer being studied, and “random” corresponds to a randomly initialized (un-trained) model.\nAre higher standard deviations a key to transfer performance, or merely an artefact of natural language pretraining? The answer to this question remains unclear, yet these statistics hint at a possible issue with the artificial model. Indeed, since its parameters do not deviate by a lot from their original values, the task may be learnt by something else than the Transformer layers.\nIs the artificial task learnt only in the embeddings? We take a look at the word embeddings of the PCFG+Zipf model by projecting them on a 2D space using a PCA.\nPCA projection on a 2D plane of the word embeddings from the artificial model. Each point has a color corresponding to its dependency relation tag. Some clusters are larger than others because the number of vocabulary elements assigned to a dependency relation is a function of the number of unique lemmas corresponding to that relation in the real data.\nAs we can see, the embeddings are pretty well clustered by dependency relations. This is expected in part because knowing precisely what relations surround a masked token is the only way to predict correctly the masked dependency relation. However, we want the model to rely on the Transformer layers rather than the embeddings to solve the task since we throw away the embeddings at the end of the artificial pretraining.\nTo enforce this behaviour, we retrain our model on artificial data but freeze the embeddings during pretraining, forcing the model to rely entirely on the position embeddings, Transformer layers and language modeling head. Interestingly, the resulting model parameter values have slightly higher standard deviations than before, indicating that it may be the Transformer layers taking over to solve the task. However, the target pretraining on Breton leads to the same accuracy as before.\nIt is plausible that our artificial task is learnt by the embeddings, yet solving this issue is inconclusive. The problem may reside in the task itself.\nCan we scale the size of our artificial dataset? The synthetic dataset is relatively small compared to the natural language datasets we use, which may explain why we fail to transfer. However, increasing the dataset size from 15 million tokens to 744 million tokens did not improve the performance, neither during the artificial pretraining (the losses are similar in both cases) nor on the target pretraining.\nThis may be a clue toward a missing ingredient in our synthetic dataset, since scaling a natural language dataset should result (until a certain limit) in improved performance. The task may be either too easy or too hard to solve, resulting in a plateau in the model performance.\nConclusion Despite our best efforts to incorporate some key characteristics of natural language in our synthetic dataset (a structured way of generating sequences and a notion of co-occurrence of tokens), we were unable to induce biases in the Transformer network that would transfer to the pretraining on a target language with smaller resources. However, we believe this is rather due to our artificial language being ill-defined than the impossibility of transferring useful capabilities to Language Models without using real data, as previous works have shown such transfer for other tasks.\nReferences [1] Training Compute-Optimal Large Language Models, Hoffmann et al., 2022. https://arxiv.org/abs/2203.15556\n[2] Does Pretraining for Summarization Require Knowledge Transfer?, Krishna et al., 2021. https://arxiv.org/abs/2109.04953\n[3] Learning Music Helps You Read: Using Transfer to Study Linguistic Structure in Language Models, Papadimitriou and Jurafsky, 2020. https://arxiv.org/abs/2004.14601\n[4] Embedding Recycling for Language Models, Saad-Falcon et al., 2022. https://arxiv.org/abs/2207.04993\n[5] When Being Unseen from mBERT is just the Beginning: Handling New Languages With Multilingual Language Models, Muller et al., 2021. https://arxiv.org/abs/2010.12858\n[6] Pretraining with Artificial Language: Studying Transferable Knowledge in Language Models, Ri and Tsuruoka, 2022. https://arxiv.org/abs/2203.10326\n","wordCount":"2210","inLanguage":"en","datePublished":"2023-02-14T00:00:00+02:00","dateModified":"2023-02-14T00:00:00+02:00","author":{"@type":"Person","name":"Roman Castagné"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://romancast.github.io/posts/artificial_data/"},"publisher":{"@type":"Organization","name":"Roman Castagné","logo":{"@type":"ImageObject","url":"https://romancast.github.io/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=https://romancast.github.io/ accesskey=h title="Home (Alt + H)"><img src=https://romancast.github.io/apple-touch-icon.png alt aria-label=logo height=35>Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></div></div><ul id=menu><li><a href=https://romancast.github.io/about/ title="About me"><span>About me</span></a></li><li><a href=https://romancast.github.io/projects/ title=Projects><span>Projects</span></a></li><li><a href=https://romancast.github.io/posts/ title=Posts><span>Posts</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://romancast.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://romancast.github.io/posts/>Posts</a></div><h1 class=post-title>Artificial Pretraining of Masked Language Models</h1><div class=post-meta><span title='2023-02-14 00:00:00 +0200 +0200'>February 14, 2023</span>&nbsp;·&nbsp;11 min&nbsp;·&nbsp;2210 words&nbsp;·&nbsp;Roman Castagné</div></header><div class=post-content><p>According to Chinchilla scaling laws for Transformers <a href=#references>[1]</a>, data may soon be a bottleneck for training really large English language models. The vast majority of languages already lack data for training even moderately sized networks.</p><p>Thus, during the last few months, we experimented with the following question: what if we could pretrain Masked Language Models (MLM, think BERT or RoBERTa) using only <strong>artificially created data</strong>, then <strong>continue pretraining on languages with very little resources</strong>? Ideally, our synthetic data could be generated quickly and be scaled to extremely large sizes as well as have properties that allow the models to “learn something”.</p><figure><img loading=lazy src=/img/artificial_data/cover_image_artificial.png alt="Language Models trained on a source language can often transfer very well to a new language, even though the vocabulary is completely disjoint. Can we do the same with artificial data?"><figcaption><p>Language Models trained on a source language can often transfer very well to a new language, even though the vocabulary is completely disjoint. Can we do the same with artificial data?</p></figcaption></figure><blockquote><p>Yes, but how will it know what “New York” is?</p></blockquote><p>The intent behind this work is not to entirely replace language data, but rather to see whether we can teach the networks to <strong>learn some simple operations</strong> before having to cope with semantics and meaning. Similar work was done for automatic summarization <a href=#references>[2]</a>, showing that teaching a model to perform a few basic operations using synthetic data (e.g. copy one line) almost matches the performance of a fully pretrained model.</p><p>A secondary objective of this work is to understand what features are learnt from the training data by language models, and how much are they used when transferring to another language. Previous works <a href=#references>[3]</a> have shown that it was possible to pre-train a model on a different modality than text (e.g. music) and still transfer to natural language with great performance. What information is learnt that makes this transfer possible?</p><p>⚠️ <strong>Disclaimer:</strong> Our work falls into the &ldquo;negative results&rdquo; category. Nonetheless, we bumped into interesting questions and thought it would be nice to present our results informally here.</p><p><em>This work was done as part of my PhD supervised by Benoît Sagot and Éric de la Clergerie, funded by the PRAIRIE chair of Benoît Sagot.</em></p><h1 id=the-method>The Method<a hidden class=anchor aria-hidden=true href=#the-method>#</a></h1><p>We start by training Masked Language Models on &ldquo;source&rdquo; data, i.e. either natural language data or synthetic data (<a href=#our-methods>see below</a> for the description of our synthetic data). For all our experiments, we work with encoder models similar to BERT with 12 layers and hidden size 768, processing sequences of length at most 128. We use batches containing 256 samples and train for 100k steps with AdamW, using a linearly decaying learning rate of at most 1e-4 and a warmup for the first 10k steps. This is a modest setup in terms of training but it enables us to experiment with new ideas pretty quickly.</p><p>We then continue training on a target language. We keep all the source parameters except the embeddings (our source language has no vocabulary overlap with the target language) and retrain using the same hyperparameters except for the batch size which we reduce to 128 samples. We usually stop training around 50k iterations to save compute because the models have already started overfitting at that point.</p><img src=/img/artificial_data/parts_trained.png><p>We use the Breton subset of <a href=https://oscar-project.org>OSCAR</a> 21.09 as our low-resource target language. It corresponds to around 5M tokens. In addition, Breton appears in the Wikiann NER dataset, which makes it possible to study finetuning setups.</p><p>We describe in the following section the source data we considered, including our synthetic language.</p><hr><h1 id=what-we-tried>What we tried<a hidden class=anchor aria-hidden=true href=#what-we-tried>#</a></h1><h3 id=our-methods>Our methods<a hidden class=anchor aria-hidden=true href=#our-methods>#</a></h3><p>We try to identify a few key characteristics in natural data that should appear in our artificial language as well.</p><ul><li><strong>Structure</strong>; natural data has a structure, whether it be images, text or sound. Since word embeddings are context-independent, we hypothesize that the structure is mainly modelled with the Transformer layers and the positional embeddings and that we should be able to transfer it to the target language.</li><li><strong>Co-occurrence</strong>; this is a very vague term encompassing a lot of higher concepts such as meaning. However, we think it may be important to learn making context-dependent decisions.</li></ul><p>To create artificial structure, we use dependency trees from the French GSD treebank to learn a Probabilistic Context Free Grammar (PCFG). Using this PCFG, we sample new trees that we linearize to form sequences. This process yields sequences of tags corresponding each to a dependency relation.</p><img src=/img/artificial_data/tree_generation.png><p>We then relexicalize these tags with items from a vocabulary chosen arbitrarily. We do not apply any other linguistically-inspired rules. Our goal is rather to construct data generated from an underlying structure than “natural-sounding sentences”.</p><p>Our first method for relexicalization (which we will call <strong>PCFG+Zipf</strong>) does not account for co-occurrences within sentences. We assign to each dependency relation a vocabulary size (computed using real statistics about that dependency relation) and a set of tokens of the corresponding size. We then relexicalize sequences of tags by drawing a token for each dependency relation from its set, using a Zipf law.</p><p>Inspired from Ri and Tsuruoka <a href=#references>[6]</a> we also try another method (<strong>PCFG+loglinear</strong>) for linearization which aims at enforcing a notion of context. We create vocabulary sets for each dependency relation similarly to the PCFG+Zipf method. Every token from each set is assigned a random embedding vector $v_s \in \mathbb{R}^d$. Then, for each sequence of tags, we randomly draw a “topic vector” $v_t\in \mathbb{R}^d$ and sample for each dependency relation a vocabulary element $w\in S_{tag}$ according to the following distribution:</p><p>$$
p(w|t) = \frac{\exp(v_w \cdot v_t)}{\sum_{s\in S_{tag}}\exp(v_s \cdot v_t)}
$$</p><p>Intuitively, the words that are similar according to their (random) embeddings will be often sampled together, thus creating a notion of co-occurrence within sentences.</p><p>For both methods, we generate a corpus of 1 million sentences, corresponding roughly to 15 million tokens. We use a total vocabulary size of 5000 elements and keep only the 20 most used dependency relations when constructing the PCFG.</p><h3 id=the-baselines>The Baselines<a hidden class=anchor aria-hidden=true href=#the-baselines>#</a></h3><p>The Language Model representations are surprisingly robust to new modalities and languages. Thus, previous works have for instance recycled models to create new ones in languages with fewer data <a href=#references>[4]</a> or added languages to multilingual models after training <a href=#references>[5]</a>.</p><p>Our baseline is similar. We use the same setting described earlier to train a model on English OSCAR data, then re-initialize its embeddings and retrain it on Breton data. This is a particularly efficient baseline compared to pretraining from scratch.</p><p>As a control and to test the influence of the source language on the transfer, we train Language Models on Czech and Turkish. They belong to different language (sub)families than Breton and have different syntax.</p><p>As we will see later, the three models (English, Czech and Turkish) transfer to Breton with almost the same accuracy, demonstrating a very moderate impact of the source language syntax on the final representations.</p><hr><h1 id=results>Results<a hidden class=anchor aria-hidden=true href=#results>#</a></h1><p>We present in the following graph the MLM evaluation accuracies obtained by each of the models on the OSCAR Breton subset.</p><p>The models trained on synthetic data <strong>fail to significantly improve</strong> on a model trained from scratch on Breton. The models pretrained on natural language however improve by roughly 3 accuracy points compared to pretraining from scratch. Adding a level of co-occurrence (the PCFG+loglinear model) did not seem to help the transfer.</p><figure><img loading=lazy src=/img/artificial_data/accuracies.png alt="Maximum evaluation accuracy on the Breton Masked Language Modelling task using each of the different source pretraining methods. The x-axis corresponds to the source pretraining data. &amp;ldquo;From scratch&amp;rdquo; was initialized randomly before the target pretraining."><figcaption><p>Maximum evaluation accuracy on the Breton Masked Language Modelling task using each of the different source pretraining methods. The x-axis corresponds to the source pretraining data. &ldquo;From scratch&rdquo; was initialized randomly before the target pretraining.</p></figcaption></figure><p>In the following section, we look at a few questions that arose when trying to understand what may be the cause of the different transfer accuracies.</p><hr><h1 id=analysis>Analysis<a hidden class=anchor aria-hidden=true href=#analysis>#</a></h1><p>In the process of trying to design a better synthetic language and understanding the source of failure when transferring to a target (natural) language, we came across a few interesting questions and experiments that we detail here.</p><h3 id=how-important-are-position-embeddings-in-the-transfer>How important are position embeddings in the transfer?<a hidden class=anchor aria-hidden=true href=#how-important-are-position-embeddings-in-the-transfer>#</a></h3><p>We transfer two types of modules when pretraining on the target language, Breton: the Transformer layers and the positional embeddings. Although we reason mostly around the Transformer layers as encoding structure in our sentences, we may be diminishing the importance of good positional embeddings trained on natural data.</p><p>To test this effect, we reset the positional embeddings at the beginning of pretraining on the target language and look at the validation accuracy.</p><figure><img loading=lazy src=/img/artificial_data/pos_vs_no_pos_embeddings.png alt="Evaluation MLM accuracy during target pretraining on Breton using the English pretrained model."><figcaption><p>Evaluation MLM accuracy during target pretraining on Breton using the English pretrained model.</p></figcaption></figure><p>We can see that re-initializing the positional embeddings only delays training for a few steps, but does not impact the final performance. The same effect appears for a model trained using artificial data. From that experiment, we concluded that the Transformer layers are mostly responsible for the transfer to the target language.</p><h3 id=how-different-are-the-models-trained-with-artificial-data-and-natural-language-data>How different are the models trained with artificial data and natural language data?<a hidden class=anchor aria-hidden=true href=#how-different-are-the-models-trained-with-artificial-data-and-natural-language-data>#</a></h3><p>The models trained on different modalities transfer with very different accuracies to the target language. Can we identify some statistics in the model parameters that correlate with a better transfer performance? To answer this question, we looked at the mean, standard deviation and maximum parameter values of every layer and every module in our models. The average weight values give very little information, as both types of models (trained on natural or synthetic data) have similar statistics.</p><p>The standard deviations are quite different, however. Despite being trained with the same hyperparameters, the models trained on natural data exhibit larger standard deviations than the models trained on artificial data, which stay closer to the standard deviation set at initialization. The following graph shows the standard deviations of weights and biases from every module.</p><figure><img loading=lazy src=/img/artificial_data/standard_dev_params.png alt="Standard deviations of each module parameter values. The x-axis corresponds to the layer being studied, and &amp;ldquo;random&amp;rdquo; corresponds to a randomly initialized (un-trained) model."><figcaption><p>Standard deviations of each module parameter values. The x-axis corresponds to the layer being studied, and &ldquo;random&rdquo; corresponds to a randomly initialized (un-trained) model.</p></figcaption></figure><p>Are higher standard deviations a key to transfer performance, or merely an artefact of natural language pretraining? The answer to this question remains unclear, yet these statistics hint at a possible issue with the artificial model. Indeed, since its parameters do not deviate by a lot from their original values, the task may be learnt by something else than the Transformer layers.</p><h3 id=is-the-artificial-task-learnt-only-in-the-embeddings>Is the artificial task learnt only in the embeddings?<a hidden class=anchor aria-hidden=true href=#is-the-artificial-task-learnt-only-in-the-embeddings>#</a></h3><p>We take a look at the word embeddings of the PCFG+Zipf model by projecting them on a 2D space using a PCA.</p><figure><img loading=lazy src=/img/artificial_data/embeddings_pca.png alt="PCA projection on a 2D plane of the word embeddings from the artificial model. Each point has a color corresponding to its dependency relation tag. Some clusters are larger than others because the number of vocabulary elements assigned to a dependency relation is a function of the number of unique lemmas corresponding to that relation in the real data."><figcaption><p>PCA projection on a 2D plane of the word embeddings from the artificial model. Each point has a color corresponding to its dependency relation tag. Some clusters are larger than others because the number of vocabulary elements assigned to a dependency relation is a function of the number of unique lemmas corresponding to that relation in the real data.</p></figcaption></figure><p>As we can see, the embeddings are pretty well clustered by dependency relations. This is expected in part because knowing precisely what relations surround a masked token is the only way to predict correctly the masked dependency relation. However, we want the model to rely on the Transformer layers rather than the embeddings to solve the task since we throw away the embeddings at the end of the artificial pretraining.</p><p>To enforce this behaviour, we retrain our model on artificial data but freeze the embeddings during pretraining, forcing the model to rely entirely on the position embeddings, Transformer layers and language modeling head. Interestingly, the resulting model parameter values have slightly higher standard deviations than before, indicating that it may be the Transformer layers taking over to solve the task. However, the target pretraining on Breton leads to the same accuracy as before.</p><p>It is plausible that our artificial task is learnt by the embeddings, yet solving this issue is inconclusive. The problem may reside in the task itself.</p><h3 id=can-we-scale-the-size-of-our-artificial-dataset>Can we scale the size of our artificial dataset?<a hidden class=anchor aria-hidden=true href=#can-we-scale-the-size-of-our-artificial-dataset>#</a></h3><p>The synthetic dataset is relatively small compared to the natural language datasets we use, which may explain why we fail to transfer. However, increasing the dataset size from 15 million tokens to 744 million tokens did not improve the performance, neither during the artificial pretraining (the losses are similar in both cases) nor on the target pretraining.</p><p>This may be a clue toward a missing ingredient in our synthetic dataset, since scaling a natural language dataset should result (until a certain limit) in improved performance. The task may be either too easy or too hard to solve, resulting in a plateau in the model performance.</p><hr><h1 id=conclusion>Conclusion<a hidden class=anchor aria-hidden=true href=#conclusion>#</a></h1><p>Despite our best efforts to incorporate some key characteristics of natural language in our synthetic dataset (a structured way of generating sequences and a notion of co-occurrence of tokens), we were unable to induce biases in the Transformer network that would transfer to the pretraining on a target language with smaller resources. However, we believe this is rather due to our artificial language being ill-defined than the impossibility of transferring useful capabilities to Language Models without using real data, as previous works have shown such transfer for other tasks.</p><hr><h1 id=references>References<a hidden class=anchor aria-hidden=true href=#references>#</a></h1><p>[1] Training Compute-Optimal Large Language Models, <em>Hoffmann et al., 2022</em>. <a href=https://arxiv.org/abs/2203.15556>https://arxiv.org/abs/2203.15556</a></p><p>[2] Does Pretraining for Summarization Require Knowledge Transfer?, <em>Krishna et al., 2021</em>. <a href=https://arxiv.org/abs/2109.04953>https://arxiv.org/abs/2109.04953</a></p><p>[3] Learning Music Helps You Read: Using Transfer to Study Linguistic Structure in Language Models, <em>Papadimitriou and Jurafsky, 2020</em>. <a href=https://arxiv.org/abs/2004.14601>https://arxiv.org/abs/2004.14601</a></p><p>[4] Embedding Recycling for Language Models, <em>Saad-Falcon et al., 2022</em>. <a href=https://arxiv.org/abs/2207.04993>https://arxiv.org/abs/2207.04993</a></p><p>[5] When Being Unseen from mBERT is just the Beginning: Handling New Languages With Multilingual Language Models, <em>Muller et al., 2021</em>. <a href=https://arxiv.org/abs/2010.12858>https://arxiv.org/abs/2010.12858</a></p><p>[6] Pretraining with Artificial Language: Studying Transferable Knowledge in Language Models, <em>Ri and Tsuruoka, 2022</em>. <a href=https://arxiv.org/abs/2203.10326>https://arxiv.org/abs/2203.10326</a></p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2023 <a href=https://romancast.github.io/>Roman Castagné</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>